{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tp Exp\u00e9rimentations","text":""},{"location":"#etat-du-tp","title":"\u00c9tat du TP","text":"<p>D\u00e9crivez ici l'\u00e9tat d'avancement du TP.</p>"},{"location":"#reponses-aux-questions","title":"R\u00e9ponses aux questions","text":"<p>Indiquez ici les r\u00e9ponses aux questions pos\u00e9es dans le TP. Vous reprendrez le num\u00e9ro de la section et le num\u00e9ro de la question. Par exemple pour r\u00e9pondre \u00e0 la question 3 de la section 2.4 vous indiquerez :</p>"},{"location":"#strategie-1","title":"Strat\u00e9gie 1","text":""},{"location":"#question-11a","title":"Question 1.1.a","text":"<p>Pour analyser la complexit\u00e9 de l'algorithme, je propose de compter le nombre de comparaisons effectu\u00e9es entre les \u00e9l\u00e9ments de la liste des marqueurs <code>(markers)</code> et ceux de la liste des marqueurs positifs <code>(positive)</code>.</p>"},{"location":"#question-11b","title":"Question 1.1.b","text":"<p>Oui, il existe un pire des cas pour cet algorithme. Il se produit lorsque tous les marqueurs de la liste markers ne se trouvent pas dans la liste <code>positive</code>.</p> <p>Donc pour chaque marqueur de markers de taille n, l\u2019algorithme parcourt enti\u00e8rement la liste positive de taille p.</p> <p>Donc dans ce pire cas, notre algorithme aura besoin de <code>n*p</code> comparaisons.</p>"},{"location":"#question-11c","title":"Question 1.1.c","text":"<p>Dans le pire des cas, aucun des marqueurs de la liste <code>markers</code> ne se trouve dans la liste <code>positive</code>. Cela implique que pour chaque marqueur <code>m</code>, nous devons parcourir toute la liste <code>positive</code> taille p pour pour conclure qu'il est n\u00e9gatif.</p> <p>Le nombre total de comparaisons dans ce cas est donc:</p> <pre><code>C1(m,p) = m*p\n</code></pre>"},{"location":"#strategie-2","title":"Strat\u00e9gie 2","text":""},{"location":"#question-22","title":"Question 2.2:","text":"<p>Oui, il existe un pire cas pour cet algorithme qui se produit lorsque, tous les \u00e9l\u00e9ments de markers ne sont pas dans positive, obligeant ainsi la l'algrithme essay\u00e9 tout les cas possibles avant de conclure qu'il es n\u00e9gatif.</p>"},{"location":"#la-borne-superieure-pour-le-nombre-doperations-c2m-p","title":"La borne sup\u00e9rieure pour le nombre d'op\u00e9rations <code>C2(m, p)</code>:","text":"<p>L'algorithme <code>negative_markers2</code> a besoin en deux \u00e9tapes principales :</p> <ol> <li> <p>Tri de positive avec merge_sort</p> </li> <li> <p>Le tri a une complexit\u00e9 en <code>O(p log p)</code>.</p> </li> <li> <p>Recherche dichotomique pour chaque \u00e9l\u00e9ment de markers</p> </li> </ol> <p>La recherche dichotomique fait <code>O(log p)</code> comparaisons par chaque \u00e9l\u00e9ment de markers.</p> <p>Donc comme il y a m \u00e9l\u00e9ments dans markers, le co\u00fbt total de cette \u00e9tape est <code>O(m log p)</code>.</p> <p>Donc la borne sup\u00e9rieure pour le nombre d'op\u00e9rations <code>C2(m, p)</code> est :</p> <pre><code>C2(m,p)=O(p*log(p)+m*log(p))\n</code></pre>"},{"location":"#strategie-3","title":"Strat\u00e9gie 3","text":""},{"location":"#question-22_1","title":"Question 2.2:","text":"<p>Notre algorithme parcourt notre liste de markers qui a pour taille <code>m+p</code> (liste contenant les markers et les positifs) qu'une seul fois en \u00e0 chaque \u00e9lement on fait deux op\u00e9rations de comparaisons une avec l'\u00e9lement d'avant et une avec seul apr\u00e8s.</p> <p>Ce qui sera repr\u00e9sent\u00e9 par:</p> <pre><code>C3_1(m,p)=O(m+p)*2\n</code></pre> <p>Mais par contre le principal cout utilis\u00e9 par notre algorithme c'est le cout du tri, et le pire du cas dans ce cas sera li\u00e9 au op\u00e9ration li\u00e9 \u00e0 la partie du tri, et qui sera que les marqueurs et les marqueurs positifs sont tri\u00e9s dans l\u2019ordre inverse par exemple quand <code>markers = [10, 8, 6, 4, 2]</code> et <code>positive = [9, 7, 5, 3, 1]</code>.</p> <p>Ce qui sera repr\u00e9sent\u00e9 par:</p> <pre><code>C3_2(m,p)=O((m + p) log (m + p))\n</code></pre> <p>Donc notre borne sup\u00e9rieure <code>C3(m, p)</code> est :</p> <pre><code>C3_1(m,p) + C3_2(m,p) = C3(m,p) = O( (m+p) log (m+p) + m + p )\n</code></pre>"},{"location":"experience/","title":"Experience module","text":"<p>Module to manage experiences</p> <p>An experience is made of a set of markers and a subset of those markers that have been tested positive. </p> Author <p>Dpt Informatique - FST - Univ. Lille 2018, january</p>"},{"location":"experience/#src.experience.Experience","title":"<code>Experience</code>","text":"Source code in <code>src/experience.py</code> <pre><code>class Experience:\n\n    def __init__(self,p,m):\n        \"\"\"\n        Creates the results of an experience on `p` positive markers\n        among `m` markers.\n\n        Args:\n          p (int): The number of positive markers (must be less or equal \n                   than the numbers of markers in `m`)\n          m (int): The number of markers (must be greater than 0)\n        \"\"\"\n        assert (p &lt;= m)\n        self.markers = marker.Marker.markers(m)\n        l = list(self.markers)\n        random.shuffle(l)\n        self.experience = l[0:p]\n\n    def get_markers (self):\n        \"\"\"\n        Returns:\n          Array of Marker: The markers that have been tested during the experience.\n\n        Examples:\n          &gt;&gt;&gt; e = Experience(6,10)\n          &gt;&gt;&gt; m = e.get_markers()\n          &gt;&gt;&gt; len(m)\n          10\n          &gt;&gt;&gt; sorted([ repr(i) for i in m])\n          ['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9']\n        \"\"\"\n        return self.markers\n\n    def get_positive_markers (self):\n        \"\"\"\n        Returns:\n          Array of Marker: The positive markers.\n\n        Examples:\n          &gt;&gt;&gt; e = Experience(10,100)\n          &gt;&gt;&gt; p = e.get_positive_markers()\n          &gt;&gt;&gt; len(p)\n          10\n        \"\"\"\n        return self.experience\n</code></pre>"},{"location":"experience/#src.experience.Experience.__init__","title":"<code>__init__(p, m)</code>","text":"<p>Creates the results of an experience on <code>p</code> positive markers among <code>m</code> markers.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>int</code> <p>The number of positive markers (must be less or equal         than the numbers of markers in <code>m</code>)</p> required <code>m</code> <code>int</code> <p>The number of markers (must be greater than 0)</p> required Source code in <code>src/experience.py</code> <pre><code>def __init__(self,p,m):\n    \"\"\"\n    Creates the results of an experience on `p` positive markers\n    among `m` markers.\n\n    Args:\n      p (int): The number of positive markers (must be less or equal \n               than the numbers of markers in `m`)\n      m (int): The number of markers (must be greater than 0)\n    \"\"\"\n    assert (p &lt;= m)\n    self.markers = marker.Marker.markers(m)\n    l = list(self.markers)\n    random.shuffle(l)\n    self.experience = l[0:p]\n</code></pre>"},{"location":"experience/#src.experience.Experience.get_markers","title":"<code>get_markers()</code>","text":"<p>Returns:</p> Type Description <p>Array of Marker: The markers that have been tested during the experience.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; e = Experience(6,10)\n&gt;&gt;&gt; m = e.get_markers()\n&gt;&gt;&gt; len(m)\n10\n&gt;&gt;&gt; sorted([ repr(i) for i in m])\n['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9']\n</code></pre> Source code in <code>src/experience.py</code> <pre><code>def get_markers (self):\n    \"\"\"\n    Returns:\n      Array of Marker: The markers that have been tested during the experience.\n\n    Examples:\n      &gt;&gt;&gt; e = Experience(6,10)\n      &gt;&gt;&gt; m = e.get_markers()\n      &gt;&gt;&gt; len(m)\n      10\n      &gt;&gt;&gt; sorted([ repr(i) for i in m])\n      ['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9']\n    \"\"\"\n    return self.markers\n</code></pre>"},{"location":"experience/#src.experience.Experience.get_positive_markers","title":"<code>get_positive_markers()</code>","text":"<p>Returns:</p> Type Description <p>Array of Marker: The positive markers.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; e = Experience(10,100)\n&gt;&gt;&gt; p = e.get_positive_markers()\n&gt;&gt;&gt; len(p)\n10\n</code></pre> Source code in <code>src/experience.py</code> <pre><code>def get_positive_markers (self):\n    \"\"\"\n    Returns:\n      Array of Marker: The positive markers.\n\n    Examples:\n      &gt;&gt;&gt; e = Experience(10,100)\n      &gt;&gt;&gt; p = e.get_positive_markers()\n      &gt;&gt;&gt; len(p)\n      10\n    \"\"\"\n    return self.experience\n</code></pre>"},{"location":"marker/","title":"Marker module","text":"<p>Module to manage markers </p> <p>A marker is a represented as a String. </p> Author <p>Dpt Informatique - FST - Univ. Lille 2018, january</p>"},{"location":"marker/#src.marker.Marker","title":"<code>Marker</code>","text":"Source code in <code>src/marker.py</code> <pre><code>class Marker:\n\n    def __init__ (self,number):\n        \"\"\"\n        Creates a new Marker.\n\n        Args:\n            number (int): The number of the marker (must be greater or equal than zero)\n        \"\"\"\n        assert(type(number) is int)\n        assert(number &gt;= 0)\n        self.number = number\n\n    def cmp (self,other):\n        \"\"\"\n        Compares this marker and `other`.\n\n        Args:\n          other (Marker): The first marker\n\n        Returns:\n          int: -1, 0 or 1 resp. if `self &lt; other`, `self == other` or `self &gt; other`\n\n        Examples:\n          &gt;&gt;&gt; Marker(45).cmp(Marker(234))\n          -1\n          &gt;&gt;&gt; Marker(45).cmp(Marker(45))\n          0\n          &gt;&gt;&gt; Marker(45).cmp(Marker(24))\n          1\n        \"\"\"\n        if self.number == other.number:\n            return 0\n        elif self.number &lt; other.number:\n            return -1\n        else:\n            return 1\n\n    def __repr__ (self):\n        return \"m{}\".format(self.number)\n\n    @staticmethod\n    def markers (p):\n        \"\"\"\n        Returns a list of `p` markers. Markers are in a random order.\n\n        Args:\n          p (int): The number of markers (must be strictly greater than 0).\n\n        Returns:\n          list of String: The list of markers\n\n        Examples:\n          &gt;&gt;&gt; import marker\n          &gt;&gt;&gt; sorted([\"{}\".format(i) for i in marker.Marker.markers(10)])\n          ['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9']\n        \"\"\"\n        assert(p &gt; 0)\n        l = [ Marker(i) for i in range(p) ]\n        random.shuffle(l)\n        return l\n</code></pre>"},{"location":"marker/#src.marker.Marker.__init__","title":"<code>__init__(number)</code>","text":"<p>Creates a new Marker.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The number of the marker (must be greater or equal than zero)</p> required Source code in <code>src/marker.py</code> <pre><code>def __init__ (self,number):\n    \"\"\"\n    Creates a new Marker.\n\n    Args:\n        number (int): The number of the marker (must be greater or equal than zero)\n    \"\"\"\n    assert(type(number) is int)\n    assert(number &gt;= 0)\n    self.number = number\n</code></pre>"},{"location":"marker/#src.marker.Marker.cmp","title":"<code>cmp(other)</code>","text":"<p>Compares this marker and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Marker</code> <p>The first marker</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>-1, 0 or 1 resp. if <code>self &lt; other</code>, <code>self == other</code> or <code>self &gt; other</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Marker(45).cmp(Marker(234))\n-1\n&gt;&gt;&gt; Marker(45).cmp(Marker(45))\n0\n&gt;&gt;&gt; Marker(45).cmp(Marker(24))\n1\n</code></pre> Source code in <code>src/marker.py</code> <pre><code>def cmp (self,other):\n    \"\"\"\n    Compares this marker and `other`.\n\n    Args:\n      other (Marker): The first marker\n\n    Returns:\n      int: -1, 0 or 1 resp. if `self &lt; other`, `self == other` or `self &gt; other`\n\n    Examples:\n      &gt;&gt;&gt; Marker(45).cmp(Marker(234))\n      -1\n      &gt;&gt;&gt; Marker(45).cmp(Marker(45))\n      0\n      &gt;&gt;&gt; Marker(45).cmp(Marker(24))\n      1\n    \"\"\"\n    if self.number == other.number:\n        return 0\n    elif self.number &lt; other.number:\n        return -1\n    else:\n        return 1\n</code></pre>"},{"location":"marker/#src.marker.Marker.markers","title":"<code>markers(p)</code>  <code>staticmethod</code>","text":"<p>Returns a list of <code>p</code> markers. Markers are in a random order.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>int</code> <p>The number of markers (must be strictly greater than 0).</p> required <p>Returns:</p> Type Description <p>list of String: The list of markers</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import marker\n&gt;&gt;&gt; sorted([\"{}\".format(i) for i in marker.Marker.markers(10)])\n['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9']\n</code></pre> Source code in <code>src/marker.py</code> <pre><code>@staticmethod\ndef markers (p):\n    \"\"\"\n    Returns a list of `p` markers. Markers are in a random order.\n\n    Args:\n      p (int): The number of markers (must be strictly greater than 0).\n\n    Returns:\n      list of String: The list of markers\n\n    Examples:\n      &gt;&gt;&gt; import marker\n      &gt;&gt;&gt; sorted([\"{}\".format(i) for i in marker.Marker.markers(10)])\n      ['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9']\n    \"\"\"\n    assert(p &gt; 0)\n    l = [ Marker(i) for i in range(p) ]\n    random.shuffle(l)\n    return l\n</code></pre>"},{"location":"sorting/","title":"Sorting module","text":"<p>Sorting functions module for experience assignment</p> Author <p>Dpt Informatique - FST - Univ. Lille 2018, january</p>"},{"location":"sorting/#src.sorting.merge","title":"<code>merge(t1, t2, cmp)</code>","text":"<p>Given two sorted lists, creates a fresh sorted list.</p> <p>Parameters:</p> Name Type Description Default <code>t1</code> <code>list</code> <p>A list of objects</p> required <code>t2</code> <code>list</code> <p>A list of objects</p> required <code>cmp</code> <code>function</code> <p>A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b</p> required Complexity <p>Time complexity of merge is \\(O(n_1+n_2)\\) with \\(n_1\\) and \\(n_2\\) resp. the length of <code>t1</code> and <code>t2</code></p> <p>Returns:</p> Name Type Description <code>list</code> <p>A fresh list, sorted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def cmp (x,y): \n...    if x == y:\n...       return 0\n...    elif x &lt; y:\n...       return -1\n...    else:\n...       return 1\n&gt;&gt;&gt; t1 = [0,2,5,6]\n&gt;&gt;&gt; t2 = [1,3,4]\n&gt;&gt;&gt; merge(t1,t2,cmp)\n[0, 1, 2, 3, 4, 5, 6]\n</code></pre> Source code in <code>src/sorting.py</code> <pre><code>def merge (t1,t2, cmp):\n    \"\"\"\n    Given two sorted lists, creates a fresh sorted list.\n\n    Args:\n      t1 (list): A list of objects\n      t2 (list): A list of objects\n      cmp (function): A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b\n\n    Note: Complexity\n          Time complexity of merge is $O(n_1+n_2)$ with\n          $n_1$ and $n_2$ resp. the length of `t1` and `t2`\n\n\n    Returns:\n      list: A fresh list, sorted.\n\n    Examples:\n      &gt;&gt;&gt; def cmp (x,y): \n      ...    if x == y:\n      ...       return 0\n      ...    elif x &lt; y:\n      ...       return -1\n      ...    else:\n      ...       return 1\n      &gt;&gt;&gt; t1 = [0,2,5,6]\n      &gt;&gt;&gt; t2 = [1,3,4]\n      &gt;&gt;&gt; merge(t1,t2,cmp)\n      [0, 1, 2, 3, 4, 5, 6]\n    \"\"\"\n    n1 = len(t1)\n    n2 = len(t2)\n    t = [0 for i in range(n1+n2)]\n    i = j = k = 0\n    while i &lt; n1 and j &lt; n2:\n        if cmp(t1[i],t2[j]) &lt; 0:\n            t[k] = t1[i]\n            i = i + 1\n        else:\n            t[k] = t2[j]\n            j = j + 1\n        k = k + 1\n    while i &lt; n1:\n        t[k] = t1[i]\n        i = i + 1\n        k = k + 1\n    while j &lt; n2:\n        t[k] = t2[j]\n        j = j + 1\n        k = k + 1\n    return t\n</code></pre>"},{"location":"sorting/#src.sorting.merge_sort","title":"<code>merge_sort(t, cmp)</code>","text":"<p>A sorting function implementing the merge sort algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>list</code> <p>A list of elements</p> required <code>cmp</code> <code>function</code> <p>A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b</p> required Complexity <p>Time complexity of merge sort is \\(\\Theta(n\\log n)\\) with \\(n\\) the length of <code>t</code>.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A fresh list, sorted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import marker\n&gt;&gt;&gt; def cmp (x,y): \n...    return x.cmp(y)\n&gt;&gt;&gt; t = marker.Marker.markers(10)\n&gt;&gt;&gt; merge_sort(t,cmp)\n[m0, m1, m2, m3, m4, m5, m6, m7, m8, m9]\n</code></pre> Source code in <code>src/sorting.py</code> <pre><code>def merge_sort (t,cmp):\n    \"\"\"\n    A sorting function implementing the merge sort algorithm.\n\n    Args:\n      t (list): A list of elements\n      cmp (function): A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b\n\n    Note: Complexity\n          Time complexity of merge sort is $\\Theta(n\\log n)$ with\n          $n$ the length of `t`.\n\n    Returns:\n      list: A fresh list, sorted.\n\n    Examples:\n      &gt;&gt;&gt; import marker\n      &gt;&gt;&gt; def cmp (x,y): \n      ...    return x.cmp(y)\n      &gt;&gt;&gt; t = marker.Marker.markers(10)\n      &gt;&gt;&gt; merge_sort(t,cmp)\n      [m0, m1, m2, m3, m4, m5, m6, m7, m8, m9]\n\n    \"\"\"\n    n = len(t)\n    if n &lt;= 1:\n        # cas de base\n        return copy.deepcopy(t)\n    else:\n        # cas general\n        t1 = merge_sort((t[0:((n-1)//2+1)]),cmp)\n        t2 = merge_sort((t[((n-1)//2+1):n]),cmp)\n        return merge(t1,t2,cmp)\n</code></pre>"},{"location":"test/","title":"Test module","text":"<p>Test module for experiences assignment</p> Author <p>Dpt Informatique - FST - Univ. Lille 2018, january</p>"},{"location":"test/#src.test.compare","title":"<code>compare(m1, m2)</code>","text":"<p>Compares two markers</p> <p>Parameters:</p> Name Type Description Default <code>m1</code> <code>Marker</code> <p>A marker </p> required <code>m2</code> <code>Marker</code> <p>Another marker</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>-1 if <code>m1 &lt; m2</code>, 0 if <code>m1 = m2</code> or 1 when <code>m1 &gt; m2</code></p> Source code in <code>src/test.py</code> <pre><code>def compare (m1,m2):\n    '''\n    Compares two markers\n\n    Args:\n      m1 (Marker): A marker \n      m2 (Marker): Another marker\n\n    Returns:\n      int: -1 if `m1 &lt; m2`, 0 if `m1 = m2` or 1 when `m1 &gt; m2`\n    '''\n    return m1.cmp(m2)\n</code></pre>"},{"location":"test/#src.test.negative_markers1","title":"<code>negative_markers1(markers, positive)</code>","text":"<p>Computes the list of negative markers from the list of markers and the list of positive markers.</p> <p>Parameters:</p> Name Type Description Default <code>markers</code> <code>list of Marker</code> <p>The list of markers </p> required <code>positive</code> <code>list of Marker</code> <p>The list of positive markers</p> required <p>Returns:</p> Type Description <p>list of Marker: The list of negative markers</p> Source code in <code>src/test.py</code> <pre><code>def negative_markers1(markers,positive):\n    \"\"\"\n    Computes the list of negative markers from the list of markers and\n    the list of positive markers.\n\n    Args:\n      markers (list of Marker): The list of markers \n      positive (list of Marker): The list of positive markers\n\n    Returns:\n      list of Marker: The list of negative markers\n    \"\"\"\n    global cpt\n    # Liste pour stocker les marqueurs n\u00e9gatifs\n    negative = []\n    for marker in markers:\n        # R\u00e9initialisation de trouve pour chaque marqueur\n        trouve = False\n        for pos_marker in positive:\n            cpt+=1\n            if compare(marker, pos_marker) == 0:\n                trouve = True\n                # On s'arr\u00eate d\u00e8s qu'on trouve le marqueur \u00e0 la liste des marqueurs positif\n                break\n        if not trouve:\n            negative.append(marker)\n    return negative\n</code></pre>"}]}